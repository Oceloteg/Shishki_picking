# SHISHKI_NOTES.md

Документ описывает **полную бизнес‑логику** приложения “Шишки / Picking” и ключевые нюансы имплементации (UI, API, синхронизация, 1С:Фреш OData, типовые ошибки и защитные правила).

---

## 1) Назначение и границы

Приложение предназначено для **сборки заказов покупателей** (документ `ЗаказПокупателя`) на складе с тач‑устройств:

- до авторизации — только ввод пароля;
- после авторизации — канбан‑доска активных заказов;
- полноэкранный режим сборки заказа с управлением количеством собранного по позициям;
- локальное хранение прогресса + best‑effort синхронизация в 1С (статусы и/или “КоличествоСобрано”).

---

## 2) Термины

- **Заказ** — документ 1С `ЗаказПокупателя`.
- **Строка / позиция** — строка табличной части `Запасы` (`Document_ЗаказПокупателя_Запасы`).
- **Нужно / заказано** — `Количество` в строке.
- **Собрано** — локальный прогресс (и при наличии — поле 1С `КоличествоСобрано`).
- **Baseline** — “снимок” состава и количеств строк при первом появлении заказа в приложении; используется для подсветки изменений.
- **Outbox (очередь)** — локальная очередь операций записи в 1С (статус/прогресс) с ретраями.

---

## 3) Авторизация

### 3.1 UI
До авторизации показывается **только поле ввода пароля** и кнопка “Войти”.

### 3.2 Токен
После успешного логина бекенд выставляет cookie‑токен:

- хранится **30 дней**;
- cookie должна быть **HttpOnly** (JS не читает), `SameSite=Lax`;
- предназначено для работы в локальной сети на тач‑устройствах.

---

## 4) Экран 1 — Канбан (список заказов)

### 4.1 Колонки
Достаточно 3 колонок:

1) **Новые** (или “Не начаты”)
2) **В сборке**
3) **Собраны**

### 4.2 Логика распределения по колонкам
Колонка определяется **прогрессом сборки** (локально) и/или статусом 1С:

- **Новые**: прогресс == 0 (ничего не собрано).
- **В сборке**: прогресс > 0, но не 100%.
- **Собраны**: прогресс == 100%.

Дополнение: если в 1С уже стоит статус “На сборке”/“Собран”, колонка может совпадать с ним, но **источник истины по прогрессу — локальные данные**.

### 4.3 Что показываем на карточке заказа (экран 1)
- Номер заказа
- Клиент
- Дата создания
- Дедлайн (дата отгрузки) — если есть
- Прогресс в формате: `collected_qty / total_qty (pct%)`
- Список позиций: номенклатура и `собрано / нужно` (+ единица)

**Комментарий** не показывается на экране 1 (только на экране 2).

### 4.4 Сортировка заказов (без переключателей)
Единая логика сортировки:

1) Сначала заказы с дедлайном (если дедлайн задан и не “нулевой”)
2) По **дню дедлайна** (время игнорируется)
3) При равном дедлайне выше те, кто **раньше созданы**
4) Заказы без дедлайна — ниже, сортировка по дате создания

### 4.5 Индикация срочности (текст)
- если дедлайн **сегодня** → “дедлайн сегодня”
- если дедлайн **завтра** → “дедлайн завтра”
- если дедлайн прошёл → “дедлайн просрочен”
- остальные дедлайны не писать текстом (можно отображать “Отгрузка до DD.MM.YYYY” как отдельную строку)

### 4.6 “Покраснение” (визуальная срочность)
Карточка получает класс срочности по двум факторам:

- **дедлайн** (сегодня — критично, завтра — предупреждение)
- **возраст заказа** (“висит Nд”, округление до дней)

Пороговые значения “давно висит” задаются конфигом (например: warn от 3 дней, danger от 7 дней).
В UI эти уровни отображаются разными классами срочности.

---

## 5) Экран 2 — Сборка заказа (полный экран)

### 5.1 Шапка экрана 2
Показывает то же, что и карточка на экране 1 + **Комментарий** заказа.

Также есть кнопка **“Назад”** (возврат на экран 1).

### 5.2 Прокрутка
Если заказ большой, экран 2 должен прокручиваться:

- шапка может быть фиксированной,
- список строк — в отдельном scroll‑контейнере,
- футер (кнопка “Назад”) доступен/закреплён.

Цель: всегда можно добраться до кнопок строк.

### 5.3 Управление строкой
По каждой строке доступны кнопки:

- `−` уменьшить `собрано`
- `+` увеличить `собрано`
- `Заполнить всё` → установить `собрано = нужно`

### 5.4 Дробные количества (кг и т.п.)
Кнопки `+`/`−` работают с “умным шагом”:

- шаг определяется по первой значащей цифре после запятой в `нужно`:
  - 0.7 → шаг 0.1
  - 0.05 → шаг 0.01
  - 2.5 → шаг 0.1
  - целые значения → шаг 1

После изменения значение округляется до соответствующей точности, чтобы не появлялись артефакты float.

### 5.5 Поведение готовой строки
Когда `собрано == нужно` (или `>=` с учётом округлений):

- строка подсвечивается зелёным;
- шрифт уменьшается;
- кнопки скрываются;
- строка **перемещается вниз** — но **только в момент**, когда она впервые стала полностью собранной.

Важно: **при частичных изменениях** (0→1→2…) строки не должны “прыгать” и пересортировываться.

### 5.6 Редактирование готовой строки
Кнопки у готовой строки снова становятся доступными по:

- **долгому нажатию** на тач‑экране или
- **двойному клику** мышью.

### 5.7 Завершение заказа
Когда все строки (кроме removed) собраны:

- на 3 секунды поверх заказа показывается полупрозрачная зелёная галочка;
- затем авто‑возврат на экран 1.

Если нажата кнопка “Завершить сборку” при недособранных строках, приложение дописывает
в комментарий заказа список “Несобранные позиции: ...” (и отправляет комментарий в 1С через outbox).

---

## 6) Прогресс заказа (ключевое правило)

Прогресс считается **по количеству**, а не по количеству строк:

- `total_qty = sum(qty_ordered)` по строкам (исключая `is_removed`)
- `collected_qty = sum(min(qty_collected, qty_ordered))` по тем же строкам
- `pct = collected_qty / total_qty * 100`

Пример: если в заказе есть 0.2 + 0.7 + 5 + 3 = 8.9, прогресс на карточке: `0 / 8.9 (0%)`.

---

## 7) История изменений заказа (baseline‑diff)

### 7.1 Что требуется показывать на экране 2
- Позиция **удалена** из заказа после baseline → красная строка, перечёркивание одной линией.
- Позиция **добавлена** после baseline → оранжевый фон (до полного заполнения).
- **Изменилось количество**:
  - новое количество подсветить оранжевым;
  - показать дельту: `+N` (добавили) или `−N` (убрали), где N — разница с baseline.

### 7.2 Как это хранится локально
На строке:
- `baseline_qty_ordered`
- `is_added`
- `is_removed`

На заказе:
- `baseline_captured_at` (когда зафиксирован baseline)

### 7.3 Как строится baseline
- При первом появлении заказа в локальной БД фиксируем baseline по всем строкам.
- При последующих синхронизациях:
  - строка исчезла из 1С → не удаляем, помечаем `is_removed=True`;
  - появилась новая строка → `is_added=True`, baseline_qty=0;
  - изменилось количество → baseline не переписываем.

Экран 1:
- removed‑строки обычно скрываем (чтобы не засорять карточку).
Экран 2:
- показываем и removed, и added, и qty‑changes.

---

## 8) Бизнес‑статусы и “активные заказы” в 1С

### 8.1 Определение активных заказов
Активные — это заказы, которые:

- `Posted == false`
- `DeletionMark == false`
- статус (по Description из справочника состояний) в наборе:
  - “На сборке”
  - “В работе”
  - “Собран” (показываем в колонке “Собраны”)

### 8.2 Когда убирать заказ из приложения
Убирать, если:
- заказ проведён (`Posted == true`),
- или удалён,
- или перешёл в статусы “отгружен/завершен” (если используются отдельные состояния).

Список “закрывающих” статусов лучше держать в конфиге.

### 8.3 Смена статуса при сборке (задано бизнесом)
- При открытии заказа для сборки → ставим статус “На сборке”.
- При полной сборке → ставим статус “Собран”.

Если включён `ONEC_SYNC_PICKING_STATE=true`, дополнительно пишем поле `ONEC_ORDER_PICKING_STATE_FIELD`
кодами `ONEC_PICK_STATE_PICKING` и `ONEC_PICK_STATE_PICKED` соответственно.

---

## 9) 1С:Фреш OData — практические нюансы

### 9.1 Базовый URL
`ONEC_BASE_URL` должен указывать на `.../odata/standard.odata/` и иметь **заканчивающий слэш**.

### 9.2 Сущности
Используем:
- `Document_ЗаказПокупателя`
- `Document_ЗаказПокупателя_Запасы`
- `Catalog_СостоянияЗаказовПокупателей`
- `Catalog_Номенклатура`
- `Catalog_Контрагенты`
- (опционально) справочник единиц

### 9.3 Ссылка‑GUID как Edm.String + *_Type
В данной базе встречается паттерн:

- поле ссылки хранит GUID, но тип у него `Edm.String`;
- рядом присутствует поле `<Поле>_Type`.

Пример (заказ):
- `СостояниеЗаказа = "<guid>"`
- `СостояниеЗаказа_Type = "StandardODATA.Catalog_СостоянияЗаказовПокупателей"`

Пример (строка):
- `Номенклатура = "<guid>"`, `Номенклатура_Type = "StandardODATA.Catalog_Номенклатура"`
- `ЕдиницаИзмерения = "<guid>"`, `ЕдиницаИзмерения_Type = "StandardODATA.Catalog_КлассификаторЕдиницИзмерения"`

### 9.4 Важнейшее правило записи статуса: обязательно *_Type
При записи составного/ссылочного поля 1С может вернуть ошибку вида:

> “Для свойства ‘СостояниеЗаказа’ ... не найдено поле с указанием типа!”

Значит при MERGE/PATCH надо отправлять **оба поля**:
- `СостояниеЗаказа = "<guid>"`
- `СостояниеЗаказа_Type = "<type>"`

### 9.5 Нельзя фильтровать по `СостояниеЗаказа` на сервере
Попытки `... and (СостояниеЗаказа eq guid'...')` или иные сравнения могут приводить к HTTP 500:

> “Нельзя сравнивать поля неограниченной длины и несовместимых типов...”

Поэтому:
- на OData сервере фильтруем только `Posted/DeletionMark`;
- статусы фильтруем **client‑side** после получения данных.

### 9.6 “СтатусСборки” — это НЕ статус заказа
После включения подсистемы “Сборка заказов” появляется поле `СтатусСборки` (обычно число/код).

Это **не** то же самое, что `СостояниеЗаказа`:

- `СостояниеЗаказа` отвечает за “В работе / На сборке / Собран”;
- `СтатусСборки` — внутренний статус механизма сборки (может быть 0/1/2…).

Никогда не используйте `СтатусСборки` как `ONEC_ORDER_STATUS_KEY_FIELD`.

### 9.7 Нулевые даты
Значение `0001-01-01T00:00:00` трактуем как `None`.

---

## 10) Локальная БД и источник истины

### 10.1 Где хранится прогресс
Источник истины — локальная БД (SQLite):

- прогресс по строкам (`qty_collected`);
- baseline и флаги изменений;
- очередь операций записи в 1С (outbox).

В 1С прогресс/статус — **дублирование** и синхронизация best‑effort.

### 10.2 Таймзоны (защита от падений)
SQLite может вернуть datetime без tzinfo. Любые вычисления “now - created_at” должны работать с UTC‑aware датами:

- если дата naive → считать UTC;
- не допускать смешения naive/aware (иначе `TypeError`).

---

## 11) Синхронизация (pull) и очередь записи (push/outbox)

### 11.1 Pull‑синхронизация (получение заказов)
- периодически загружаем активные заказы из 1С;
- для каждого заказа загружаем строки;
- резолвим:
  - статус (GUID → Description),
  - контрагента,
  - номенклатуру,
  - единицы.

Рекомендуется кэширование справочников (TTL), чтобы не дергать 1С по каждой строке.

### 11.2 Push через outbox
Операции записи в 1С выполняются **не напрямую из UI**, а через очередь:

- `set_status` (смена статуса заказа)
- `write_progress` (запись `КоличествоСобрано` в строку, если доступно)

### 11.3 Ретраи, backoff и блокировки
- при ошибках “заблокирован/lock/conflict” — увеличиваем паузу;
- храним `attempts`, `next_attempt_at`, `last_error`;
- UI не должен падать 500 из‑за проблем 1С.

### 11.4 Обязательное подтверждение записи статуса
После отправки статуса:
- выполняем GET документа и сверяем, что `СостояниеЗаказа` действительно изменилось.
Если не изменилось — считаем попытку неуспешной и ретраим позже.

### 11.5 Частные ошибки 1С и как их трактовать
- HTTP 400 “не найдено поле типа” → всегда означает отсутствие `*_Type` при записи.
- HTTP 404 “Экземпляр сущности не найден”:
  - документ мог стать проведённым/удалённым/изменился контур (не тот base url),
  - такую запись из outbox лучше помечать как failed после нескольких ретраев.
- Если запись `КоличествоСобрано` проходит без ошибки, но чтение даёт `None`,
  значит поле не опубликовано/не доступно на запись в OData — нужно включить его в публикации 1С.

---

## 12) API (контракт)

Минимальный набор:

### 12.1 Авторизация
- `POST /api/login` (password)
- `POST /api/logout`
- `GET /api/me`

### 12.2 Данные/синхронизация
- `GET /api/config` — конфигурация UI (пороги срочности, статусы).
- `GET /api/orders` — список заказов для доски
- `GET /api/orders/{order_id}` — подробности + строки (включая removed для экрана 2)
- `POST /api/sync-now` — ручная синхронизация (тяжелее, использовать кнопкой)
- `POST /api/orders/{order_id}/open` — открыть для сборки (локально + outbox set_status)
- `PATCH /api/orders/{order_id}/lines/{line_id}` — изменить собранное по строке (локально + outbox write_progress)
- `POST /api/orders/{order_id}/complete` — завершить (локально + outbox set_status “Собран”)

### 12.3 Отладка
Рекомендуется:
- `GET /api/debug/onec-active` — что реально вернуло 1С (для диагностики фильтрации)
- `GET /api/debug/outbox` — состояние очереди записи
- `GET /api/debug/db` — статистика локальной БД

---

## 13) Frontend (важные договоренности)

### 13.1 Не ломать маршруты
Фронт должен вызывать “каноничные” маршруты:

- изменение строки: `PATCH /api/orders/{order_id}/lines/{line_id}`

Использование `/api/lines/{id}` запрещено (это был временный/устаревший путь и приводил к 404 и “не работают +/−”).

### 13.2 Автообновление
Рекомендуемый режим:

- фронт периодически (например каждые 10–15 сек) делает **только** `GET /api/orders` и перерисовывает доску без блокировки действий;
- `/api/sync-now` не дергать постоянно (только кнопкой “Обновить”).
- Дополнительно допускается разовый `/api/sync-now` при запуске клиента в фоне (не блокируя UI).

### 13.3 Кэш браузера (важно)
- favicon и JS/CSS часто кэшируются агрессивно;
- после обновлений статики использовать hard refresh (Ctrl+F5).

---

## 14) Favicon и статика

- favicon должен быть доступен по `/favicon.ico` и отдавать `Content-Type: image/x-icon`.
- в HTML должен быть `<link rel="icon" href="/favicon.ico" ...>`.
- если не обновляется — это кэш браузера.

---

## 15) scripts/onec_probe — обязательный диагностический сценарий

Скрипт probe используется для проверки OData и настройки `.env`.

Он должен уметь:

1) скачать `$metadata`
2) найти 1 заказ по `Posted=false & DeletionMark=false`
3) показать поля верхнего уровня (подсказки для `.env`)
4) подтянуть справочник статусов и распечатать:
   - GUID → Description
   - какие статусы считаются активными (настройка)
5) загрузить строки (`_Запасы`) и показать поля (подсказки для `.env`)
6) проверить “логика приложения fetch_active_orders()”:
   - показать сколько заказов попадёт в активные
7) постранично посчитать количество заказов по базовому фильтру (без статусов)
8) (опционально) выполнить тест записи статуса:
   - поменять статус “В работе” → “На сборке”
   - прочитать обратно и подтвердить
   - вернуть обратно и подтвердить
9) (опционально) выполнить тест записи собранного количества:
   - прочитать строку с номенклатурой в запасе.
   - добавить количество собранного
   - прочитать что количество установилось
   - вернуть обратно и подтвердить

Тест записи должен включаться флагом окружения (чтобы не портить прод):
- `ONEC_PROBE_WRITE_STATUS=1`

---

## 16) Конфигурация (.env) — основные параметры

### 16.1 Приложение
- `APP_PASSWORD`
- `APP_SECRET_KEY`
- `APP_DEBUG`
- `APP_LOG_LEVEL`

### 16.2 1С OData
- `ONEC_MODE=odata`
- `ONEC_BASE_URL=.../odata/standard.odata/`
- `ONEC_USERNAME`
- `ONEC_PASSWORD`
- `ONEC_TIMEOUT_SECONDS`
- `ONEC_VERIFY_TLS`
- `ONEC_CONCURRENCY`

### 16.3 Маппинг полей (настраиваемо под конкретную базу)
Заказ:
- `ONEC_ORDER_STATUS_KEY_FIELD=СостояниеЗаказа`
- `ONEC_ORDER_CUSTOMER_KEY_FIELD=Контрагент_Key`
- `ONEC_ORDER_SHIP_DEADLINE_FIELD=ДатаОтгрузки`
- `ONEC_ORDER_COMMENT_FIELD=Комментарий`

Строки:
- `ONEC_LINE_ITEM_KEY_FIELD=Номенклатура`
- `ONEC_LINE_QTY_FIELD=Количество`
- `ONEC_LINE_PROGRESS_FIELD=КоличествоСобрано`
- `ONEC_LINE_UNIT_FIELD=ЕдиницаИзмерения`

Пикинг‑поля 1С (дополнительно):
- `ONEC_ORDER_PICKING_STATE_FIELD=СтатусСборки` (НЕ использовать как статус заказа)
- `ONEC_SYNC_PICKING_STATE=true/false`
- `ONEC_PICK_STATE_NOT_STARTED=0`
- `ONEC_PICK_STATE_PICKING=1`
- `ONEC_PICK_STATE_PICKED=2`

Интервалы:
- `SYNC_INTERVAL_SECONDS=60`
- `OUTBOX_INTERVAL_SECONDS=5`

UI‑пороги “давно висит” (для визуальной срочности):
- `STALE_WARN_DAYS=3`
- `STALE_DANGER_DAYS=7`

---

## 17) Чек‑лист защитных правил (чтобы не повторять найденные баги)

1) **Никогда** не фильтровать заказы по `СостояниеЗаказа` на стороне OData — возможен HTTP 500.
2) Всегда сравнивать строки статусов (`Description`) через `casefold()` (русский регистр отличается: “В работе” vs “В Работе”).
3) При записи `СостояниеЗаказа` всегда отправлять `СостояниеЗаказа_Type`.
4) `СтатусСборки` — не статус заказа.
5) Любые записи в 1С — через outbox + ретраи + backoff; UI не должен падать.
6) После записи статуса — подтверждать чтением.
7) Экран 2: строки не должны пересортировываться при частичных изменениях; перенос вниз только при полной готовности.
8) Для дробных количеств — умный шаг и округление.
9) Даты из SQLite/1С приводить к UTC‑aware, иначе возможны падения “naive/aware”.
10) При обновлении фронта — помнить про кэш (Ctrl+F5).

---
