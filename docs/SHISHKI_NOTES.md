# Шишки / Picking — заметки по интеграции и типовым ошибкам

Этот файл — «памятка» по условиям проекта и уже найденным граблям, чтобы не повторять ошибки при дальнейших доработках.

## 1) Бизнес-правила (активные заказы)
- Активные заказы: статус **«На сборке»** или **«В работе»**, которые **не проведены** (`Posted=false`), и не помечены на удаление.
- Собранные заказы видим в колонке **«Собраны»** до тех пор, пока заказ не станет:
  - **отгружен**,
  - **завершен**,
  - **проведен**.
- При открытии заказа для сборки выставляем статус **«На сборке»** (best-effort в 1С).
- При полной сборке выставляем статус **«Собран»** (best-effort в 1С).
- Основной прогресс сборки хранится локально; в 1С — только дублирование/синхронизация при наличии подходящих полей.

## 2) OData/1С особенности (важно)
### 2.1 GUID хранится в Edm.String + поле *_Type
В вашей публикации `standard.odata` некоторые поля ссылочного типа приходят как:
- `Edm.String` со значением GUID (например `СостояниеЗаказа`, `Номенклатура`, `ЕдиницаИзмерения`)
- и рядом поле `<Поле>_Type` (например `СостояниеЗаказа_Type`) с типом сущности.

Нельзя трактовать такие поля как «человекочитаемую строку». Нужно:
- резолвить GUID → `Description` через соответствующий справочник.

### 2.2 Пустые даты 1С
1С часто возвращает «пустую дату» как:
- `0001-01-01T00:00:00`

Её надо считать `None`, иначе UI начнёт показывать «год 1» и ломать логику дедлайнов.

### 2.3 Фильтр по статусу на стороне сервера может возвращать пусто
Было замечено: OData запросы с `$filter` по полю статуса иногда возвращают `200 OK`, но `value=[]`, даже когда заказы есть.

Поэтому в клиенте реализован fallback:
- если серверная фильтрация дала 0, запрашиваем заказы без фильтра статуса (только Posted/DeletionMark) и фильтруем статусы в приложении.

### 2.4 Регистрозависимость названий статусов
`Description` статуса может быть `«В работе»`, а в конфиге легко поставить `«В Работе»`.

Сравнения статусов должны быть:
- **case-insensitive** (используем `.casefold()`).

## 3) Производительность запросов
### 3.1 Не использовать `$orderby=Date desc` для «поиска одного заказа»
На больших базах 1С может сортировать до применения `$top` → таймаут.

В пробнике и клиенте предпочтительно:
- сначала получить `Ref_Key` (`$select=Ref_Key&$top=1`) без сортировки,
- затем читать документ по ключу.

## 4) Даты/таймзоны и SQLite
### 4.1 SQLite может терять tzinfo
Даже если колонка `DateTime(timezone=True)`, SQLite часто возвращает datetime **без tzinfo**.
Это приводит к ошибкам вида:
- `TypeError: can't subtract offset-naive and offset-aware datetimes`

Решение:
- перед арифметикой дат принудительно приводить datetime к timezone-aware UTC.

## 5) Диагностика
- `python -m scripts.onec_probe` — проверка доступности OData и примеров данных (заказы, строки, статусы, резолвинг номенклатуры).
- Если заказы не отображаются:
  - проверить, что `fetch_active_orders()` возвращает >0,
  - затем проверить, что `/api/sync-now` реально апсертит заказы в локальную БД,
  - проверить `/api/orders` (ошибки 500 обычно связаны с датами/таймзоной или схемой данных).

## 6) Конфигурация (env)
Минимум для OData:
- `ONEC_MODE=odata`
- `ONEC_BASE_URL=.../odata/standard.odata/`
- `ONEC_USERNAME=...`
- `ONEC_PASSWORD=...`
- `ONEC_ORDER_STATUS_KEY_FIELD=СостояниеЗаказа`
- `ONEC_LINE_PROGRESS_FIELD=КоличествоСобрано`
- `ONEC_ACTIVE_STATUSES=На сборке,В работе,Собран`

Для логов:
- `APP_DEBUG=true`
- `APP_LOG_LEVEL=DEBUG`

Пароль формы задаётся через `APP_PASSWORD` (в примере — `shishki-pick-2025`), а параметры подключения к 1С держим только в секретах окружения и не коммитим в репозиторий.
## 7) Совместимость и частые регрессии
- **PATCH строк**: единственный рабочий маршрут — `PATCH /api/orders/{order_id}/lines/{line_id}`.
- **enqueue_set_status** должен быть tolerant к доп. аргументам (например `pick_status_code`), иначе
  `POST /api/orders/{id}/open` может падать `500` и заказ не будет переходить в колонку «В сборке».
- **favicon**: для стабильного отображения иконки:
  - отдаём `/favicon.ico` с `media_type="image/x-icon"`
  - в `static/index.html` добавляем `<link rel="icon" href="/favicon.ico" ...>`
  - учитываем агрессивный кэш фавикона в браузерах (иногда нужен hard refresh).
- **Колонки в UI**: фронт использует `order.column`, рассчитанный на backend, а поля `/api/config` называются
  `status_picking/status_picked` без префикса `onec_` (переименования на фронте не допускаются).
